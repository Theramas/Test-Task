#Тестовое задания для вакансии (Python) 

#Обзор

Необходимо покрыть предложенный код тест-кейсом, написанным при помощи стандартной библиотеки Python3 'unittest'. Также, необходимо найти и указать несоответствия между спецификацией и самим кодом. Проект содержит три файла:

 - 'task_for_set_vacancy.py' предложенный для тестирования код
 - 'try_until_test.py' файл тесст кейса
 - 'try_until_fixed.py' вариант предложенного для тестирования кода с 	исправлениями

#Тестируемый код

Представлена функция 'try_until', которая является частью большего модуля. Функция принимает обязательный аргумент 'func'(некая неопределенная функция), один аргумент со значением по-умолчанию 'interval' и несколько опциональных аргументов. Исходя из предложенной спецификации и логики работы кода, функция должна соответствовать следующим требованиям:

 - повторять вызов фукнции 'func', пока она поднимает exc.TryAgainError 	эксепшн(исключение).
 - если 'func' возвращает некий результат, тестируемая функция должна остановить итерации и вернуть этот результат
 - если указанный таймаут превышен, функция должна поднять исключение exc.UserTimeoutError
 - если был задан аргумент 'times', 'func' будет вызвана указанное количество раз. При превышении повторов будет поднято исключение exc.UserTimeoutError

Тестируемая функция также записывает определнные сообщения в лог. Часть сообщений может быть изменена на пользовательские путем указания опциональных аргументов 'try_msg' и 'error_msg' при вызове функции.

#Несоответствия в спецификации

В спецификации указано, что повтор вызова функции 'func' должен происходить, когда 'func' поднимает исключение  exc.TryAgainError. Однако, в тестируемом коде присутствует только один блок except, который будет задействован при поднятии любого исключения и остановит итерации. Повтор вызова 'func' произойдет только если эта функция не поднимет ни одного исключения и не вернет некий результат. 

Одно из возможных решений заключается в том, чтобы переместить часть кода
    log.debug("Wait {:.2f} seconds before the next attempt".format(interval))
        time.sleep(interval)
        num += 1
в дополнительный блок 'except exc.TryAgainError'. Содержимое блока 'else' тоже должно быть перемещено в новый except блок.

Строка 22 тестируемого кода содержит стринг с форматируемой частью {0}, однако метод .format не вызван. Стринг не содержит какой-либо полезной информации и без вызова .format бесполезен. Логичным решением будет добавить .format(num). Тогда строка будет форматироваться порядковым номером текущей итерации и сообщение в логе станет более информативным.  

Все предложенные решения, а также мелкие грамматические исправления, приведены в файле 'try_until_fixed.py'.

#Тест план

Правильно функционирующий тестовый код должен приводить к 4 основным результатам, как указано в спецификации. Таким образом, основными тестовыми сценариями являются:

 - проверка, что 'try_until' возвращает результат вызова 'func', если таковой имеется

 - проверка, что в случае вывода ошибки или исключения при вызове 'func', 'try_until' поднимет исключение exc.Error.
 - проверка, что в случае превышения количества повторов будет поднято исключение exc.UserTimeoutError с соответствующим сообщением
 - проверка, что в случае превышения таймаута будет поднято исключение exc.UserTimeoutError с соответствующим сообщением

Также, функция может быть вызвана с пользовательскими выходными данными с использованием опциональных аргументов. Код должен функционировать корректно при введении правильных и неправильных пользовательских данных. Таким образом, необходимо протестировать два дополнительных сценария:

 - проверка, что 'try_until' функционирует корректно при вводе правильных пользовательских входных данных
 - проверка, что 'try_until' функционирует корректно при вводе неправильных пользовательских входных данных

Все эти сценарии покрыты в тест кейсе 'try_until_test.py'.
